# -*- coding: utf-8 -*-
"""M20CS017_M20CS020_PA1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ab2IKLxCt0StD7tKWIo77h8tdy7xsELk
"""

#Importing libraries
!pip install opencv-python==3.4.2.17
!pip install opencv-contrib-python==3.4.2.17
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import cv2 as cv
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import copy

"""1. Finding of the Ground Truth Correspondence and matching the pixels"""

#reading the images
image1, image2 = cv.imread("/content/im1.jpg"), cv.imread("/content/im2.jpg")
#the K matrix in array
K = np.array([[1698.873755, 0.000000,    971.7497705],
    [0.000000,    1698.8796645, 647.7488275],
    [0.000000,    0.000000,     1.000000]])
#using the sift library for feature matching
sift = cv.xfeatures2d.SIFT_create()

keypoints1, des1= sift.detectAndCompute(image1, None)
keypoints2, des2= sift.detectAndCompute(image2, None)

matches = cv.BFMatcher(cv.NORM_L1, crossCheck=True).match(des1,des2)

matched_img = cv.drawMatches(image1, keypoints1, image2, keypoints2, matches[:30], None)

print('*****************Pixel Matching****************************')
cv2_imshow(matched_img)
#new array pi, p2 for storing the correspondence points
p1=[]
p2=[]
for match in matches:
  p1.append(keypoints1[match.queryIdx].pt)
  p2.append(keypoints2[match.trainIdx].pt)
p1=np.array(p1)
p2=np.array(p2)
print('*****************Ground Truth Correspondence***************************')
print(p1, p2)
pixel_map=[]
for i in range(0,len(p1)):
  pixel_map.append([p1[i][1], p1[i][0], p2[i][1], p2[i][0]])
print('n = ', len(matches))

"""2. Finding the Essential Matrix"""

#stroing the correspondence points in pi_temp and p2_temp
p1_temp,p2_temp = p1,p2
  
Kinv = np.linalg.inv(K)
print('----------------------------K inverse----------------------------------')
print(Kinv)
#making the points homogeneous points by adding 1 in z axis by making into 3D
z = np.ones((1797,1))
p1_temp=np.append(p1_temp, z, axis=1)
p2_temp=np.append(p2_temp, z, axis=1)
#new empty arrays for storing xi and yi points
xi=[]
yi=[]
for i in p1_temp:
  xi.append(np.dot(Kinv, i))

for i in p2_temp:
  yi.append(np.dot(Kinv, i))
xi=np.array(xi)
yi=np.array(yi)
print('------------------------------xi---------------------------------------')  
print(xi)
print('------------------------------yi---------------------------------------')
print(yi)
#new empty array A for storing the matrix A
A=[]
for i in range(0, 1797):
  #multiplication of matrix yi transpose and p matrix
  A.append((xi[i][0]*yi[i][0], xi[i][1]*yi[i][0], yi[i][0], xi[i][0]*yi[i][1], xi[i][1]*yi[i][1], yi[i][1] ,  xi[i][0],xi[i][1]  ,1))
A=np.array(A)
print('------------------------------A----------------------------------------') 
print(A)
print('------------------------Essential Matrix-------------------------------') 
#using np.linalg.svd() for finding out the essential matrix
u, s, v = np.linalg.svd(A)
U, S, V = np.linalg.svd(np.reshape(v[:, 8], (3, 3)))
Essential_Matrix=U @ np.diag([*S[:2], 0]) @ V 
print(Essential_Matrix)

"""3. Finding the Rotation Matrix and Translation Vector """

#computing the rotation matrix and translation vector by using the formula taught in class
W=np.array([[0,-1,0],
            [1,0,0],
            [0,0,1]])

U, S, V = np.linalg.svd(Essential_Matrix)
#calculation of R1, R2, T1, T2
R1, R2, T1, T2 = U @ W @ V, U @ W.transpose() @ V, U[::, 2], -U[::, 2]
print('------------------------------R1---------------------------------------') 
print(R1)
print('------------------------------R2---------------------------------------') 
print(R2)
print('------------------------------T1---------------------------------------') 
print(T1)
print('------------------------------T2---------------------------------------')
print(T2)

"""4. Finding P using the triangulation approach"""

#using traingular approach for finding out the P
pi = []
#calculation of projection matrix for camera 1
pi1_temp = K @ np.hstack((np.identity(3), np.array([0, 0, 0]).reshape(3, 1)))
#calculation of projection matric for camera 2
pi2_temp = K @ np.hstack((R1, T1.reshape(3, 1)))

print(f'Projection matrix for camera-1:\n{pi1_temp}')
print(f'Projection matrix for camera-2:\n{pi2_temp}')
for i in range(len(pixel_map)):
  A = np.asarray([pixel_map[i][0] * pi1_temp[2, :] - pi1_temp[1, :],
        pi1_temp[0, :] - pixel_map[i][1] * pi1_temp[2, :],
        pixel_map[i][2] * pi2_temp[2, :] - pi2_temp[1, :],
        pi2_temp[0, :] - pixel_map[i][3] * pi2_temp[2, :]]).reshape(4, 4)
  # print(A)
  #using linalv.svd to solve the AP=0 equation
  U, S, V = np.linalg.svd(A)
  pt = V[0:3, 3] / V[3, 3]
  #appending all the pt points into pi
  pi.append(pt)
pi=np.array(pi)
print(pi)

"""5. Plotting P and camera center t"""

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z') 
ax.scatter(pi[:, 0], pi[:, 1], pi[:, 2], color='red')
plt.show()

